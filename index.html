<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>A Band After Midnight - AR Debugging</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px;
            display: none; /* Initially hidden */
        }
        #controls button {
            display: block;
            margin: 6px;
            padding: 10px 12px;
            color: white;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover { background-color: #666; }
        #controls button.active { background-color: #007bff; border-color: #0056b3;}

        #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5em; text-align: center;
            background: rgba(0,0,0,0.75); padding: 25px; border-radius: 10px;
            z-index: 200;
            display: none; /* Initially hidden */
        }

        #startExperienceUI {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 300; text-align: center; background: rgba(0,0,0,0.85);
            padding: 30px; border-radius: 15px; max-width: 90%; box-sizing: border-box;
        }
        #startExperienceUI h2 { margin-top: 0; color: #00aaff; }
        #startExperienceUI p { font-size: 1.1em; margin-bottom: 25px; line-height: 1.5; }
        #startArButton {
            padding: 15px 30px; font-size: 1.25em; cursor: pointer;
            background-color: #007bff; color: white; border: none;
            border-radius: 8px; font-weight: bold;
            transition: background-color 0.3s ease;
        }
        #startArButton:hover { background-color: #0056b3; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.151.0/three.module.min.js",
        "three/addons/": "https://unpkg.com/three@0.151.0/examples/jsm/",
        "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
      }
    }
    </script>
</head>
<body>
    <div id="startExperienceUI">
        <h2>Welcome to the AR Visualizer!</h2>
        <p>
            This experience uses your device's camera for Augmented Reality
            and your microphone to make the visuals react to sound.
            <br><br>
            Please click "Start" and then <strong>allow camera and microphone access</strong> when your browser asks.
        </p>
        <button id="startArButton">Start AR Experience</button>
    </div>

    <div id="loadingMessage">Loading AR Experience...</div>
    <div id="controls">
        <button id="btn-starfield" onclick="setActiveVisual('starfield')">Star Field (Debug)</button>
        <button id="btn-clouds" onclick="setActiveVisual('clouds')">Clouds</button>
        <button id="btn-water" onclick="setActiveVisual('water')">Flowing Water</button>
        <button id="btn-fireflies" onclick="setActiveVisual('fireflies')">Fireflies</button>
        <button id="btn-none" onclick="setActiveVisual('none')">Clear Visuals</button>
    </div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { MindARThree } from 'mindar-image-three';

        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector("#container");
            const loadingMessage = document.getElementById('loadingMessage');
            const controlsDiv = document.getElementById('controls');
            const startExperienceUI = document.getElementById('startExperienceUI');
            const startArButton = document.getElementById('startArButton');

            let mindarThree;
            let anchor;
            let currentVisual = null;
            let currentVisualType = 'none';
            const clock = new THREE.Clock();

            let analyser;
            let dataArray;
            const audioSummary = {
                overallAverage: 0, bassAverage: 0, midAverage: 0, trebleAverage: 0,
                dataArrayValid: false, audioContextActive: false
            };

            async function startAudio() {
                if (audioSummary.audioContextActive) return;
                if(loadingMessage) loadingMessage.innerHTML = "Requesting microphone access...";
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.7;
                    source.connect(analyser);
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    audioSummary.dataArrayValid = true;
                    audioSummary.audioContextActive = true;
                    console.log("Microphone access granted. Audio analyser active.");
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    if(loadingMessage) loadingMessage.innerHTML = "Microphone access denied/error. Audio reactivity disabled.<br><small>" + err.message + "</small>";
                }
            }

            function updateAudioSummary() {
                if (!analyser || !dataArray || !audioSummary.dataArrayValid) {
                    audioSummary.overallAverage = 10; audioSummary.bassAverage = 10;
                    audioSummary.midAverage = 10; audioSummary.trebleAverage = 10;
                    return audioSummary;
                }
                analyser.getByteFrequencyData(dataArray);
                let overallSum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const len = dataArray.length;
                const bassCutoff = Math.floor(len * 0.15);
                const midCutoff = Math.floor(len * 0.50);

                for (let i = 0; i < len; i++) {
                    const val = dataArray[i];
                    overallSum += val;
                    if (i < bassCutoff) bassSum += val;
                    else if (i < midCutoff) midSum += val;
                    else trebleSum += val;
                }
                audioSummary.overallAverage = overallSum / len || 0;
                audioSummary.bassAverage = bassCutoff > 0 ? bassSum / bassCutoff : 0;
                audioSummary.midAverage = (midCutoff - bassCutoff) > 0 ? midSum / (midCutoff - bassCutoff) : 0;
                audioSummary.trebleAverage = (len - midCutoff) > 0 ? trebleSum / (len - midCutoff) : 0;
                return audioSummary;
            }

            const textureLoader = new THREE.TextureLoader();
            let starTexture, cloudTexture, fireflyTexture; // These will be initialized in loadAllAssets

            function loadAllAssets(callback) {
                if(loadingMessage) loadingMessage.innerHTML = "Loading textures...";
                const createPlaceholderTexture = (color = 'rgba(255,255,255,0.8)', size = 64, shape = 'radial') => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    if (shape === 'radial') {
                        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                    } else { ctx.fillStyle = color; }
                    ctx.fillRect(0,0,size,size);
                    return new THREE.CanvasTexture(canvas);
                };

                starTexture = createPlaceholderTexture('rgba(230,230,255,0.9)', 32);
                cloudTexture = createPlaceholderTexture('rgba(200,200,220,0.2)', 128);
                fireflyTexture = createPlaceholderTexture('rgba(255,255,150,0.95)', 48);
                console.log("Textures initialized (using placeholders).");
                callback();
            }

            const initMindAR = async () => {
                if(loadingMessage) loadingMessage.innerHTML = "Initializing AR...<br>Please allow camera access and point at the target image.";
                
                await startAudio();

                mindarThree = new MindARThree({
                    container: container,
                    imageTargetSrc: "./targets.mind",
                    maxTrack: 1,
                    uiLoading: "no", uiScanning: "no", uiError: "yes"
                });
                const { renderer, scene, camera } = mindarThree;
                
                // For Three.js r151, if colors look off, you might need to set this.
                // MindAR 1.2.5 might handle this, but good to be aware.
                // renderer.outputEncoding = THREE.sRGBEncoding; // sRGBEncoding should be available in r151

                anchor = mindarThree.addAnchor(0);

                // DEBUGGING: Add a reference cube to the anchor
                // const debugGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                // const debugMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green
                // const debugCube = new THREE.Mesh(debugGeometry, debugMaterial);
                // debugCube.position.set(0, 0.1, 0); // Slightly above center
                // anchor.group.add(debugCube);
                // console.log("Debug cube added to anchor.");


                anchor.onTargetFound = () => {
                    console.log("Target Found! Forcing 'starfield' for debugging.");
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    setActiveVisual('starfield'); // Focus on starfield for debugging
                };
                anchor.onTargetLost = () => {
                    console.log("Target Lost.");
                     // Optionally, bring back a message or hide visuals
                    // if(loadingMessage && !anchor.visible) {
                    //    loadingMessage.innerHTML = "Target lost. Please find the image marker.";
                    //    loadingMessage.style.display = 'block';
                    // }
                };

                try {
                    await mindarThree.start();
                    renderer.setAnimationLoop(() => {
                        const delta = clock.getDelta();
                        const elapsedTime = clock.getElapsedTime();
                        const currentAudioData = updateAudioSummary();

                        if (anchor.visible && currentVisual && currentVisual.update) {
                            currentVisual.update(currentAudioData, elapsedTime, delta);
                        }
                        renderer.render(scene, camera);
                    });
                } catch (e) {
                    console.error("Error starting MindAR:", e);
                    if(loadingMessage) loadingMessage.innerHTML = "Error starting AR. Check console, permissions, and target file.<br><small>" + e.message + "</small>";
                }
            };

            function clearVisuals() {
                if (anchor && currentVisual && currentVisual.mesh) {
                    anchor.group.remove(currentVisual.mesh);
                    if (currentVisual.mesh.geometry) currentVisual.mesh.geometry.dispose();
                    if (currentVisual.mesh.material) {
                        if (Array.isArray(currentVisual.mesh.material)) {
                            currentVisual.mesh.material.forEach(m => m.dispose());
                        } else {
                            currentVisual.mesh.material.dispose();
                        }
                    }
                    // Dispose textures if they were uniquely created for this visual and not shared placeholders
                    // For now, our placeholder textures (starTexture, etc.) are global.
                    // If visuals created their own textures, you'd dispose them here.
                    // if (currentVisual.textures) {
                    //     currentVisual.textures.forEach(tex => tex.dispose());
                    // }
                    console.log("Cleared visual:", currentVisual.type);
                }
                currentVisual = null;
            }
            
            window.setActiveVisual = (type) => { // Attached to window to be accessible from HTML onclick
                if (currentVisualType === type && type !== 'none' && currentVisual && type !== 'starfield') { // Allow re-setting starfield for debug
                     // Allow re-triggering the current visual if it's 'starfield' for easier debugging clicks
                    if (type === 'starfield' && currentVisual && currentVisual.type === 'starfield') {
                        // No change, already starfield
                    } else if (currentVisualType === type && type !== 'none' && currentVisual) {
                        return;
                    }
                }


                clearVisuals();
                currentVisualType = type;

                document.querySelectorAll('#controls button').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(`btn-${type}`);
                if (activeBtn) activeBtn.classList.add('active');

                if (!anchor && type !== 'none') {
                    console.warn("AR anchor not ready, cannot create visual: " + type);
                    if(loadingMessage && loadingMessage.style.display === 'none') {
                        loadingMessage.innerHTML = "AR not fully loaded. Try finding the target again.";
                        loadingMessage.style.display = 'block';
                    }
                    return;
                }
                
                switch (type) {
                    case 'starfield': createStarField(); break;
                    case 'clouds': createClouds(); break;
                    case 'water': createFlowingWater(); break;
                    case 'fireflies': createFireflies(); break;
                    case 'none': console.log("Visuals cleared by user."); break;
                }
                if (currentVisual) console.log("Set active visual:", currentVisual.type);
            };

            const shaderNoiseFunctions = `
                float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
                float noise(vec2 p) {
                    vec2 i = floor(p); vec2 f = fract(p);
                    f = f*f*(3.0-2.0*f);
                    float r1 = mix(rand(i), rand(i + vec2(1.0,0.0)),f.x);
                    float r2 = mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)),f.x);
                    return mix(r1,r2,f.y);
                }
            `;

            // --- STARFIELD (DEBUG VERSION) ---
            function createStarField() {
                const particleCount = 500; 
                const positions = new Float32Array(particleCount * 3);
                console.log("Debugging StarField: Creating particles...");

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 1.5;   // X range: -0.75 to 0.75
                    positions[i * 3 + 1] = (Math.random() * 0.4) - 0.1;   // Y range: -0.1 to 0.3 (around where water is)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 1.5;   // Z range: -0.75 to 0.75
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.08,                 
                    color: 0xff00ff,            
                    transparent: false,         
                    opacity: 1.0,
                    blending: THREE.NormalBlending, 
                    depthWrite: true,           
                    sizeAttenuation: true       
                });
                const points = new THREE.Points(geometry, material);
                // points.position.z = 0.05; // Optional: slight Z offset

                if (anchor && anchor.group) {
                    anchor.group.add(points);
                    console.log("Debugging StarField: Mesh added to anchor group.");
                } else {
                    console.error("StarField: Anchor or anchor.group is not available!");
                    return; 
                }

                currentVisual = {
                    mesh: points, type: 'starfield',
                    update: (audioData, time) => {
                        points.rotation.y += 0.001; 
                    }
                };
            }


            // --- CLOUDS (Initial Adjustments - NOT FULL DEBUG YET) ---
            function createClouds() {
                const particleCount = 100; // Reduced for easier initial testing
                const positions = new Float32Array(particleCount * 3);
                const cloudInstanceData = [];
                console.log("Attempting to create Clouds. Anchor visible:", anchor ? anchor.visible : 'N/A');

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 2.5; // X range: -1.25 to 1.25
                    positions[i * 3 + 1] = Math.random() * 1.0 + 0.2;   // Y range: 0.2 to 1.2 (above target)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2.0 - 0.5; // Z range: -1.5 to 0.5 (some behind, some front)
                    cloudInstanceData.push({ driftX: (Math.random() - 0.5) * 0.004, driftZ: (Math.random() - 0.5) * 0.0015 });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.8, // Adjusted size - this is large if cloudTexture is small, might need tuning
                    map: cloudTexture, 
                    transparent: true, 
                    opacity: 0.5, // Increased base opacity
                    blending: THREE.NormalBlending, 
                    depthWrite: false, 
                    color: 0xffffff // Ensure white if texture has alpha
                });
                const points = new THREE.Points(geometry, material);
                
                if (anchor && anchor.group) {
                    anchor.group.add(points);
                } else { return; }

                currentVisual = {
                    mesh: points, type: 'clouds', data: cloudInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioInfluence = audioData.midAverage / 255;
                        // material.opacity = 0.4 + (audioData.overallAverage / 255) * 0.3; // Keep audio opacity simple
                        for (let i = 0; i < particleCount; i++) {
                            posAttr.array[i * 3 + 0] += (currentVisual.data[i].driftX + audioInfluence * 0.001) * (delta * 60);
                            posAttr.array[i * 3 + 2] += (currentVisual.data[i].driftZ + audioInfluence * 0.0005) * (delta * 60);
                            // Simple wrap around for X
                            if (posAttr.array[i * 3 + 0] > 1.5) posAttr.array[i * 3 + 0] = -1.5;
                            else if (posAttr.array[i * 3 + 0] < -1.5) posAttr.array[i * 3 + 0] = 1.5;
                        }
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- FLOWING WATER (Known Visible Parameters) ---
            const waterVertexShader = shaderNoiseFunctions + `
                varying vec2 vUv; uniform float uTime; uniform float uFrequency; uniform float uAmplitude;
                void main() {
                    vUv = uv; vec3 pos = position; float time = uTime * 0.15;
                    pos.z += sin(pos.x * uFrequency + time) * uAmplitude * 0.6;
                    pos.z += cos(pos.y * uFrequency * 0.7 + time * 1.3) * uAmplitude * 0.4;
                    pos.z += noise(vec2(pos.x*0.15 + time*0.2, pos.y*0.15 + time*0.1)) * uAmplitude * 0.8;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }`;
            const waterFragmentShader = shaderNoiseFunctions + `
                varying vec2 vUv; uniform float uTime; uniform vec3 uWaterColorDeep; uniform vec3 uWaterColorSurface; uniform float uOpacity;
                void main() {
                    float time = uTime * 0.03; vec2 uvT = vUv;
                    uvT.x += noise(vUv * 2.5 + time) * 0.02; uvT.y += noise(vUv * 2.5 - time * 1.2) * 0.02;
                    float n = abs(noise(uvT * 5.0 + time * 0.6));
                    vec3 waterColor = mix(uWaterColorDeep, uWaterColorSurface, smoothstep(0.25, 0.65, n));
                    float sparkleN = noise(vUv * 20.0 + time * 2.5);
                    float sparkle = pow(max(0.0, sparkleN - 0.6), 6.0) * 0.8; sparkle = smoothstep(0.0, 0.1, sparkle);
                    gl_FragColor = vec4(waterColor + sparkle, (n * 0.35 + 0.45) * uOpacity);
                }`;

            function createFlowingWater() {
                const geometry = new THREE.PlaneGeometry(1.5, 1.5, 20, 20); 
                const material = new THREE.ShaderMaterial({
                    vertexShader: waterVertexShader, fragmentShader: waterFragmentShader,
                    uniforms: {
                        uTime: { value: 0.0 }, uFrequency: { value: 2.5 }, 
                        uAmplitude: { value: 0.1 }, // Keep amplitude moderate
                        uWaterColorDeep: { value: new THREE.Color(0x001e42) },
                        uWaterColorSurface: { value: new THREE.Color(0x30a0f0) },
                        uOpacity: { value: 0.65 }
                    },
                    transparent: true, depthWrite: false, side: THREE.DoubleSide
                });
                const waterMesh = new THREE.Mesh(geometry, material);
                waterMesh.position.y = 0.05; 
                waterMesh.rotation.x = -Math.PI / 2.8; 
                
                if (anchor && anchor.group) {
                    anchor.group.add(waterMesh);
                } else { return; }

                currentVisual = {
                    mesh: waterMesh, type: 'water',
                    update: (audioData, time) => {
                        material.uniforms.uTime.value = time;
                        material.uniforms.uFrequency.value = 1.5 + (audioData.midAverage / 255) * 4.0; // Adjusted audio influence
                        material.uniforms.uAmplitude.value = 0.02 + (audioData.bassAverage / 255) * 0.10; // Adjusted audio influence
                        material.uniforms.uOpacity.value = 0.4 + (audioData.overallAverage / 255) * 0.45;
                    }
                };
            }

            // --- FIREFLIES (Initial Adjustments - NOT FULL DEBUG YET) ---
            function createFireflies() {
                const particleCount = 80; // Moderate count
                const positions = new Float32Array(particleCount * 3);
                const fireflyInstanceData = [];
                console.log("Attempting to create Fireflies. Anchor visible:", anchor ? anchor.visible : 'N/A');

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 1.8; // X range: -0.9 to 0.9
                    positions[i * 3 + 1] = (Math.random() * 0.8) - 0.2;   // Y range: -0.2 to 0.6 (around target plane)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 1.8; // Z range: -0.9 to 0.9
                    fireflyInstanceData.push({
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.005, (Math.random()-0.5)*0.0025, (Math.random()-0.5)*0.005),
                        blinkOffset: Math.random() * Math.PI * 2, targetY: positions[i * 3 + 1]
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.06, // Adjusted size
                    map: fireflyTexture, 
                    color: 0xffffaa,
                    transparent: true, 
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false, 
                    opacity: 0.9
                });
                const points = new THREE.Points(geometry, material);

                if (anchor && anchor.group) {
                    anchor.group.add(points);
                } else { return; }
                
                currentVisual = {
                    mesh: points, type: 'fireflies', data: fireflyInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioLevel = audioData.overallAverage / 255;
                        let collectiveOpacity = 0;
                        for (let i = 0; i < particleCount; i++) {
                            const ff = currentVisual.data[i];
                            posAttr.array[i * 3 + 0] += ff.velocity.x * (1 + audioLevel*0.2) * (delta*60); // Reduced audio influence on speed
                            posAttr.array[i * 3 + 1] += ff.velocity.y * (1 + audioLevel*0.1) * (delta*60);
                            posAttr.array[i * 3 + 2] += ff.velocity.z * (1 + audioLevel*0.2) * (delta*60);
                            ff.velocity.y += (ff.targetY - posAttr.array[i * 3 + 1]) * 0.0005; // Keep attraction
                            ff.velocity.multiplyScalar(0.98); // Dampen velocity
                            // Simpler random movement impulse
                            if (Math.random() < 0.01) ff.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.002, (Math.random()-0.5)*0.001, (Math.random()-0.5)*0.002));
                            // Boundary checks based on new tighter distribution
                            if (Math.abs(posAttr.array[i*3+0]) > 1.0) ff.velocity.x *= -0.8;
                            if (posAttr.array[i*3+1] < -0.3 || posAttr.array[i*3+1] > 0.7) ff.velocity.y *= -0.8;
                            if (Math.abs(posAttr.array[i*3+2]) > 1.0) ff.velocity.z *= -0.8;
                            
                            const blink = Math.sin(time * (1.0 + audioLevel*1.5) + ff.blinkOffset) + Math.sin(time*0.4 + ff.blinkOffset*0.5); // Simpler blink
                            if (blink > 0.8) collectiveOpacity += ((blink - 0.8)/1.2) * (0.5 + audioLevel*0.5);
                        }
                        material.opacity = Math.min(1.0, (collectiveOpacity / (particleCount * 0.1)) + 0.1 ); // Adjusted opacity logic
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- Application Startup Logic ---
            const beginARExperience = () => {
                if (startExperienceUI) startExperienceUI.style.display = 'none';
                if (loadingMessage) {
                    loadingMessage.innerHTML = "Loading AR assets...";
                    loadingMessage.style.display = 'block';
                }
                if (controlsDiv) controlsDiv.style.display = 'block'; 

                loadAllAssets(() => {
                    if (typeof THREE === 'undefined' || typeof MindARThree === 'undefined') {
                        if(loadingMessage) loadingMessage.innerHTML = "Error: Critical libraries (THREE or MindAR) not loaded. Check importmap and module imports.";
                        console.error("THREE or MindARThree (module) not loaded.");
                        return;
                    }
                    initMindAR().catch(err => { 
                         if(loadingMessage) loadingMessage.innerHTML = "Failed to initialize AR. Check console, permissions, and .mind file path.<br><small>" + err.message + "</small>";
                         console.error("Failed to initialize AR:", err);
                    });
                });
            };

            if (startArButton) {
                startArButton.addEventListener('click', beginARExperience);
            } else {
                console.error("Start AR Button not found. AR experience cannot be initiated by user.");
                if(loadingMessage) {
                    loadingMessage.innerHTML = "Error: Start button missing. Cannot initialize.";
                    loadingMessage.style.display = 'block';
                }
            }
        });
    </script>
</body>
</html>

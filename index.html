<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>A Band After Midnight - AR Visibility Test</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px;
            display: none; /* Initially hidden */
        }
        #controls button {
            display: block;
            margin: 6px;
            padding: 10px 12px;
            color: white;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover { background-color: #666; }
        #controls button.active { background-color: #007bff; border-color: #0056b3;}

        #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5em; text-align: center;
            background: rgba(0,0,0,0.75); padding: 25px; border-radius: 10px;
            z-index: 200;
            display: none; /* Initially hidden */
        }

        #startExperienceUI {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 300; text-align: center; background: rgba(0,0,0,0.85);
            padding: 30px; border-radius: 15px; max-width: 90%; box-sizing: border-box;
        }
        #startExperienceUI h2 { margin-top: 0; color: #00aaff; }
        #startExperienceUI p { font-size: 1.1em; margin-bottom: 25px; line-height: 1.5; }
        #startArButton {
            padding: 15px 30px; font-size: 1.25em; cursor: pointer;
            background-color: #007bff; color: white; border: none;
            border-radius: 8px; font-weight: bold;
            transition: background-color 0.3s ease;
        }
        #startArButton:hover { background-color: #0056b3; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.151.0/three.module.min.js",
        "three/addons/": "https://unpkg.com/three@0.151.0/examples/jsm/",
        "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
      }
    }
    </script>
</head>
<body>
    <div id="startExperienceUI">
        <h2>Welcome to the AR Visualizer!</h2>
        <p>
            This experience uses your device's camera for Augmented Reality
            and your microphone to make the visuals react to sound.
            <br><br>
            Please click "Start" and then <strong>allow camera and microphone access</strong> when your browser asks.
        </p>
        <button id="startArButton">Start AR Experience</button>
    </div>

    <div id="loadingMessage">Loading AR Experience...</div>
    <div id="controls">
        <button id="btn-starfield" onclick="setActiveVisual('starfield')">Star Field (Debug)</button>
        <button id="btn-clouds" onclick="setActiveVisual('clouds')">Clouds</button>
        <button id="btn-water" onclick="setActiveVisual('water')">Flowing Water</button>
        <button id="btn-fireflies" onclick="setActiveVisual('fireflies')">Fireflies</button>
        <button id="btn-none" onclick="setActiveVisual('none')">Clear Visuals</button>
    </div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { MindARThree } from 'mindar-image-three';

        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector("#container");
            const loadingMessage = document.getElementById('loadingMessage');
            const controlsDiv = document.getElementById('controls');
            const startExperienceUI = document.getElementById('startExperienceUI');
            const startArButton = document.getElementById('startArButton');

            let mindarThree;
            let anchor;
            let currentVisual = null;
            let currentVisualType = 'none';
            const clock = new THREE.Clock();

            let analyser;
            let dataArray;
            const audioSummary = {
                overallAverage: 0, bassAverage: 0, midAverage: 0, trebleAverage: 0,
                dataArrayValid: false, audioContextActive: false
            };

            async function startAudio() {
                if (audioSummary.audioContextActive) return;
                if(loadingMessage) loadingMessage.innerHTML = "Requesting microphone access...";
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.7;
                    source.connect(analyser);
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    audioSummary.dataArrayValid = true;
                    audioSummary.audioContextActive = true;
                    console.log("Microphone access granted. Audio analyser active.");
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    if(loadingMessage) loadingMessage.innerHTML = "Microphone access denied/error. Audio reactivity disabled.<br><small>" + err.message + "</small>";
                }
            }

            function updateAudioSummary() {
                if (!analyser || !dataArray || !audioSummary.dataArrayValid) {
                    audioSummary.overallAverage = 10; audioSummary.bassAverage = 10;
                    audioSummary.midAverage = 10; audioSummary.trebleAverage = 10;
                    return audioSummary;
                }
                analyser.getByteFrequencyData(dataArray);
                let overallSum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const len = dataArray.length;
                const bassCutoff = Math.floor(len * 0.15);
                const midCutoff = Math.floor(len * 0.50);

                for (let i = 0; i < len; i++) {
                    const val = dataArray[i];
                    overallSum += val;
                    if (i < bassCutoff) bassSum += val;
                    else if (i < midCutoff) midSum += val;
                    else trebleSum += val;
                }
                audioSummary.overallAverage = overallSum / len || 0;
                audioSummary.bassAverage = bassCutoff > 0 ? bassSum / bassCutoff : 0;
                audioSummary.midAverage = (midCutoff - bassCutoff) > 0 ? midSum / (midCutoff - bassCutoff) : 0;
                audioSummary.trebleAverage = (len - midCutoff) > 0 ? trebleSum / (len - midCutoff) : 0;
                return audioSummary;
            }

            const textureLoader = new THREE.TextureLoader();
            let starTexture, cloudTexture, fireflyTexture; 

            function loadAllAssets(callback) {
                if(loadingMessage) loadingMessage.innerHTML = "Loading textures...";
                const createPlaceholderTexture = (color = 'rgba(255,255,255,0.8)', size = 64, shape = 'radial') => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    if (shape === 'radial') {
                        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                    } else { ctx.fillStyle = color; }
                    ctx.fillRect(0,0,size,size);
                    return new THREE.CanvasTexture(canvas);
                };
                starTexture = createPlaceholderTexture('rgba(230,230,255,0.9)', 32);
                cloudTexture = createPlaceholderTexture('rgba(200,200,220,0.2)', 128);
                fireflyTexture = createPlaceholderTexture('rgba(255,255,150,0.95)', 48);
                console.log("Textures initialized (using placeholders).");
                callback();
            }

            const initMindAR = async () => {
                if(loadingMessage) loadingMessage.innerHTML = "Initializing AR...<br>Please allow camera access and point at the target image.";
                await startAudio();
                mindarThree = new MindARThree({
                    container: container,
                    imageTargetSrc: "./targets.mind",
                    maxTrack: 1,
                    uiLoading: "no", uiScanning: "no", uiError: "yes"
                });
                const { renderer, scene, camera } = mindarThree;
                // For Three.js r151, if colors look off:
                // renderer.outputEncoding = THREE.sRGBEncoding; 
                anchor = mindarThree.addAnchor(0);

                anchor.onTargetFound = () => {
                    console.log("Target Found!");
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    if (!currentVisual && currentVisualType === 'none') { // Only set if nothing is active
                        console.log("No current visual, setting 'starfield' (debug) as default on target found.");
                        setActiveVisual('starfield');
                    } else {
                        console.log("Target found, but a visual ("+ currentVisualType +") is already active or set.");
                    }
                };
                anchor.onTargetLost = () => {
                    console.log("Target Lost.");
                };

                try {
                    await mindarThree.start();
                    renderer.setAnimationLoop(() => {
                        const delta = clock.getDelta();
                        const elapsedTime = clock.getElapsedTime();
                        const currentAudioData = updateAudioSummary();
                        if (anchor.visible && currentVisual && currentVisual.update) {
                            currentVisual.update(currentAudioData, elapsedTime, delta);
                        }
                        renderer.render(scene, camera);
                    });
                } catch (e) {
                    console.error("Error starting MindAR:", e);
                    if(loadingMessage) loadingMessage.innerHTML = "Error starting AR. Check console, permissions, and target file.<br><small>" + e.message + "</small>";
                }
            };

            function clearVisuals() {
                if (anchor && currentVisual && currentVisual.mesh) {
                    anchor.group.remove(currentVisual.mesh);
                    if (currentVisual.mesh.geometry) currentVisual.mesh.geometry.dispose();
                    if (currentVisual.mesh.material) {
                        if (Array.isArray(currentVisual.mesh.material)) {
                            currentVisual.mesh.material.forEach(m => m.dispose());
                        } else {
                            currentVisual.mesh.material.dispose();
                        }
                    }
                    console.log("Cleared visual:", currentVisual.type);
                }
                currentVisual = null;
                // currentVisualType = 'none'; // Set here or rely on setActiveVisual to set it
            }
            
            window.setActiveVisual = (type) => {
                if (currentVisualType === type && type !== 'none' && currentVisual) {
                    console.log(`Visual ${type} is already active. No change.`);
                    return;
                }

                clearVisuals();
                currentVisualType = type; // Set type before creating

                document.querySelectorAll('#controls button').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(`btn-${type}`);
                if (activeBtn) activeBtn.classList.add('active');

                if (!anchor && type !== 'none') {
                    console.warn("AR anchor not ready, cannot create visual: " + type);
                    if(loadingMessage && loadingMessage.style.display === 'none') {
                        loadingMessage.innerHTML = "AR not fully loaded. Try finding the target again.";
                        loadingMessage.style.display = 'block';
                    }
                    currentVisualType = 'none'; // Reset if anchor not ready
                    return;
                }
                
                console.log("setActiveVisual: Attempting to create type:", type);
                switch (type) {
                    case 'starfield': createStarField(); break;
                    case 'clouds': createClouds(); break;
                    case 'water': createFlowingWater(); break;
                    case 'fireflies': createFireflies(); break;
                    case 'none': 
                        console.log("Visuals explicitly cleared by user.");
                        currentVisualType = 'none'; // Ensure type is 'none'
                        break; 
                }
                
                if (currentVisual) {
                     currentVisualType = currentVisual.type; 
                     console.log("Successfully set active visual:", currentVisual.type);
                } else if (type !== 'none') {
                    console.warn("Failed to create visual for type:", type, "- currentVisual is null.");
                    currentVisualType = 'none'; 
                }
            };

            const shaderNoiseFunctions = `float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); } float noise(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f); float r1 = mix(rand(i), rand(i + vec2(1.0,0.0)),f.x); float r2 = mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)),f.x); return mix(r1,r2,f.y); }`;

            // --- STARFIELD (DEBUG VERSION - Baseline Visibility Near Target) ---
            function createStarField() {
                const particleCount = 500;
                const positions = new Float32Array(particleCount * 3);
                console.log("Debugging StarField (Baseline): Creating particles near target plane...");

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 1.5;   // X range: -0.75 to 0.75
                    positions[i * 3 + 1] = (Math.random() * 0.4) - 0.1;   // Y range: -0.1 to 0.3 (very close to target plane)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 1.5;   // Z range: -0.75 to 0.75
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    color: 0xff00ff, 
                    transparent: false,
                    opacity: 1.0,
                    blending: THREE.NormalBlending,
                    depthWrite: true,
                    sizeAttenuation: true
                });
                const points = new THREE.Points(geometry, material);

                if (anchor && anchor.group) {
                    anchor.group.add(points);
                    console.log("Debugging StarField (Baseline): Mesh added to anchor group.");
                } else {
                    console.error("StarField (Baseline): Anchor or anchor.group is not available!");
                    currentVisual = null; // Ensure currentVisual is null if creation fails
                    return;
                }
                currentVisual = { mesh: points, type: 'starfield', update: (audioData, time) => { points.rotation.y += 0.001; }};
            }

            // --- CLOUDS (Initial Scaled-Down Adjustments) ---
            function createClouds() {
                const particleCount = 100; 
                const positions = new Float32Array(particleCount * 3);
                const cloudInstanceData = [];
                console.log("Attempting to create Clouds. Anchor visible:", anchor ? anchor.visible : 'N/A');

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 2.5; 
                    positions[i * 3 + 1] = Math.random() * 1.0 + 0.2;   
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2.0 - 0.5; 
                    cloudInstanceData.push({ driftX: (Math.random() - 0.5) * 0.004, driftZ: (Math.random() - 0.5) * 0.0015 });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.8, 
                    map: cloudTexture, 
                    transparent: true, 
                    opacity: 0.5, 
                    blending: THREE.NormalBlending, 
                    depthWrite: false, 
                    color: 0xffffff 
                });
                const points = new THREE.Points(geometry, material);
                
                if (anchor && anchor.group) {
                    anchor.group.add(points);
                } else { currentVisual = null; return; }

                currentVisual = {
                    mesh: points, type: 'clouds', data: cloudInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioInfluence = audioData.midAverage / 255;
                        material.opacity = 0.5 + (audioData.overallAverage / 255) * 0.4; 
                        for (let i = 0; i < particleCount; i++) {
                            posAttr.array[i * 3 + 0] += (currentVisual.data[i].driftX + audioInfluence * 0.001) * (delta * 60);
                            posAttr.array[i * 3 + 2] += (currentVisual.data[i].driftZ + audioInfluence * 0.0005) * (delta * 60);
                            if (posAttr.array[i * 3 + 0] > 1.5) posAttr.array[i * 3 + 0] = -1.5;
                            else if (posAttr.array[i * 3 + 0] < -1.5) posAttr.array[i * 3 + 0] = 1.5;
                        }
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- FLOWING WATER (Known Visible Parameters) ---
            const waterVertexShader = shaderNoiseFunctions + `varying vec2 vUv; uniform float uTime; uniform float uFrequency; uniform float uAmplitude; void main() { vUv = uv; vec3 pos = position; float time = uTime * 0.15; pos.z += sin(pos.x * uFrequency + time) * uAmplitude * 0.6; pos.z += cos(pos.y * uFrequency * 0.7 + time * 1.3) * uAmplitude * 0.4; pos.z += noise(vec2(pos.x*0.15 + time*0.2, pos.y*0.15 + time*0.1)) * uAmplitude * 0.8; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }`;
            const waterFragmentShader = shaderNoiseFunctions + `varying vec2 vUv; uniform float uTime; uniform vec3 uWaterColorDeep; uniform vec3 uWaterColorSurface; uniform float uOpacity; void main() { float time = uTime * 0.03; vec2 uvT = vUv; uvT.x += noise(vUv * 2.5 + time) * 0.02; uvT.y += noise(vUv * 2.5 - time * 1.2) * 0.02; float n = abs(noise(uvT * 5.0 + time * 0.6)); vec3 waterColor = mix(uWaterColorDeep, uWaterColorSurface, smoothstep(0.25, 0.65, n)); float sparkleN = noise(vUv * 20.0 + time * 2.5); float sparkle = pow(max(0.0, sparkleN - 0.6), 6.0) * 0.8; sparkle = smoothstep(0.0, 0.1, sparkle); gl_FragColor = vec4(waterColor + sparkle, (n * 0.35 + 0.45) * uOpacity); }`;

            function createFlowingWater() {
                const geometry = new THREE.PlaneGeometry(1.5, 1.5, 20, 20); 
                const material = new THREE.ShaderMaterial({ 
                    vertexShader: waterVertexShader, fragmentShader: waterFragmentShader,
                    uniforms: {
                        uTime: { value: 0.0 }, uFrequency: { value: 2.5 }, 
                        uAmplitude: { value: 0.1 },
                        uWaterColorDeep: { value: new THREE.Color(0x001e42) },
                        uWaterColorSurface: { value: new THREE.Color(0x30a0f0) },
                        uOpacity: { value: 0.65 }
                    },
                    transparent: true, depthWrite: false, side: THREE.DoubleSide
                });
                const waterMesh = new THREE.Mesh(geometry, material);
                waterMesh.position.y = 0.05; 
                waterMesh.rotation.x = -Math.PI / 2.8; 
                if (anchor && anchor.group) anchor.group.add(waterMesh); else { currentVisual = null; return; }
                currentVisual = { mesh: waterMesh, type: 'water', update: (audioData, time) => {  
                    material.uniforms.uTime.value = time;
                    material.uniforms.uFrequency.value = 1.5 + (audioData.midAverage / 255) * 4.0;
                    material.uniforms.uAmplitude.value = 0.02 + (audioData.bassAverage / 255) * 0.10;
                    material.uniforms.uOpacity.value = 0.4 + (audioData.overallAverage / 255) * 0.45;
                }};
            }

            // --- FIREFLIES (Initial Scaled-Down Adjustments) ---
            function createFireflies() {
                const particleCount = 80; 
                const positions = new Float32Array(particleCount * 3);
                const fireflyInstanceData = [];
                console.log("Attempting to create Fireflies. Anchor visible:", anchor ? anchor.visible : 'N/A');

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 1.8; 
                    positions[i * 3 + 1] = (Math.random() * 0.8) - 0.2;   
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 1.8; 
                    fireflyInstanceData.push({ 
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.005, (Math.random()-0.5)*0.0025, (Math.random()-0.5)*0.005),
                        blinkOffset: Math.random() * Math.PI * 2, targetY: positions[i * 3 + 1]
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.06, 
                    map: fireflyTexture, 
                    color: 0xffffaa,
                    transparent: true, 
                    blending: THREE.AdditiveBlending,  
                    depthWrite: false, 
                    opacity: 0.9
                });
                const points = new THREE.Points(geometry, material);

                if (anchor && anchor.group) anchor.group.add(points); else { currentVisual = null; return; }
                
                currentVisual = { 
                    mesh: points, type: 'fireflies', data: fireflyInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioLevel = audioData.overallAverage / 255;
                        let collectiveOpacity = 0;
                        for (let i = 0; i < particleCount; i++) {
                            const ff = currentVisual.data[i];
                            posAttr.array[i * 3 + 0] += ff.velocity.x * (1 + audioLevel*0.2) * (delta*60);
                            posAttr.array[i * 3 + 1] += ff.velocity.y * (1 + audioLevel*0.1) * (delta*60);
                            posAttr.array[i * 3 + 2] += ff.velocity.z * (1 + audioLevel*0.2) * (delta*60);
                            ff.velocity.y += (ff.targetY - posAttr.array[i * 3 + 1]) * 0.0005; 
                            ff.velocity.multiplyScalar(0.98); 
                            if (Math.random() < 0.01) ff.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.002, (Math.random()-0.5)*0.001, (Math.random()-0.5)*0.002));
                            if (Math.abs(posAttr.array[i*3+0]) > 1.0) ff.velocity.x *= -0.8;
                            if (posAttr.array[i*3+1] < -0.3 || posAttr.array[i*3+1] > 0.7) ff.velocity.y *= -0.8; 
                            if (Math.abs(posAttr.array[i*3+2]) > 1.0) ff.velocity.z *= -0.8;
                            const blink = Math.sin(time * (1.0 + audioLevel*1.5) + ff.blinkOffset) + Math.sin(time*0.4 + ff.blinkOffset*0.5); 
                            if (blink > 0.8) collectiveOpacity += ((blink - 0.8)/1.2) * (0.5 + audioLevel*0.5);
                        }
                        material.opacity = Math.min(1.0, (collectiveOpacity / (particleCount * 0.1)) + 0.2 ); 
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- Application Startup Logic ---
            const beginARExperience = () => {
                if (startExperienceUI) startExperienceUI.style.display = 'none';
                if (loadingMessage) { loadingMessage.innerHTML = "Loading AR assets..."; loadingMessage.style.display = 'block';}
                if (controlsDiv) controlsDiv.style.display = 'block'; 
                loadAllAssets(() => {
                    if (typeof THREE === 'undefined' || typeof MindARThree === 'undefined') {
                        if(loadingMessage) loadingMessage.innerHTML = "Error: Critical libraries (THREE or MindAR) not loaded...";
                        console.error("THREE or MindARThree (module) not loaded."); return;
                    }
                    initMindAR().catch(err => { 
                         if(loadingMessage) loadingMessage.innerHTML = "Failed to initialize AR...<br><small>" + err.message + "</small>";
                         console.error("Failed to initialize AR:", err);
                    });
                });
            };

            if (startArButton) {
                startArButton.addEventListener('click', beginARExperience);
            } else {
                console.error("Start AR Button not found...");
                if(loadingMessage) { loadingMessage.innerHTML = "Error: Start button missing..."; loadingMessage.style.display = 'block'; }
            }
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>A Band After Midnight</title>

    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px; }
        #controls button {
            display: block;
            margin: 6px;
            padding: 10px 12px;
            color: white;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover { background-color: #666; }
        #controls button.active { background-color: #007bff; border-color: #0056b3;}
        #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5em; text-align: center;
            background: rgba(0,0,0,0.75); padding: 25px; border-radius: 10px;
            z-index: 200;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.164.1/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"></script>

</head>
<body>
    <div id="loadingMessage">Loading AR Experience...<br>Please Allow Camera & Microphone Access.</div>
    <div id="controls">
        <button id="btn-starfield" onclick="setActiveVisual('starfield')">Star Field</button>
        <button id="btn-clouds" onclick="setActiveVisual('clouds')">Clouds</button>
        <button id="btn-water" onclick="setActiveVisual('water')">Flowing Water</button>
        <button id="btn-fireflies" onclick="setActiveVisual('fireflies')">Fireflies</button>
        <button id="btn-none" onclick="setActiveVisual('none')">Clear Visuals</button>
    </div>
    <div id="container"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector("#container");
            const loadingMessage = document.getElementById('loadingMessage');
            const controlButtons = document.querySelectorAll('#controls button');

            let mindarThree;
            let anchor;
            let currentVisual = null;
            let currentVisualType = 'none';
            const clock = new THREE.Clock();

            // Audio analysis setup
            let analyser;
            let dataArray;
            const audioSummary = {
                overallAverage: 0, bassAverage: 0, midAverage: 0, trebleAverage: 0,
                dataArrayValid: false, audioContextActive: false
            };

            async function startAudio() {
                if (audioSummary.audioContextActive) return;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256; // Lower for performance, higher for more detail
                    analyser.smoothingTimeConstant = 0.7; // Smoother transitions
                    source.connect(analyser);
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    audioSummary.dataArrayValid = true;
                    audioSummary.audioContextActive = true;
                    console.log("Microphone access granted. Audio analyser active.");
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    loadingMessage.innerHTML = "Microphone access denied or error. Audio reactivity will not work.<br><small>" + err.message + "</small>";
                    // Don't hide loading message if critical error occurs
                }
            }

            function updateAudioSummary() {
                if (!analyser || !dataArray || !audioSummary.dataArrayValid) {
                    // Return some default low values if audio isn't working, so visuals don't go crazy
                    audioSummary.overallAverage = 10; audioSummary.bassAverage = 10;
                    audioSummary.midAverage = 10; audioSummary.trebleAverage = 10;
                    return audioSummary;
                }
                analyser.getByteFrequencyData(dataArray);
                let overallSum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const len = dataArray.length;
                const bassCutoff = Math.floor(len * 0.15); // e.g., 0-15% of bins for bass
                const midCutoff = Math.floor(len * 0.50);  // e.g., 15-50% for mid

                for (let i = 0; i < len; i++) {
                    const val = dataArray[i];
                    overallSum += val;
                    if (i < bassCutoff) bassSum += val;
                    else if (i < midCutoff) midSum += val;
                    else trebleSum += val;
                }
                audioSummary.overallAverage = overallSum / len || 0;
                audioSummary.bassAverage = bassCutoff > 0 ? bassSum / bassCutoff : 0;
                audioSummary.midAverage = (midCutoff - bassCutoff) > 0 ? midSum / (midCutoff - bassCutoff) : 0;
                audioSummary.trebleAverage = (len - midCutoff) > 0 ? trebleSum / (len - midCutoff) : 0;
                return audioSummary;
            }

            // --- Texture Loading ---
            const textureLoader = new THREE.TextureLoader();
            let starTexture, cloudTexture, fireflyTexture;

            function loadAllAssets(callback) {
                loadingMessage.innerHTML = "Loading textures...";
                const createPlaceholderTexture = (color = 'rgba(255,255,255,0.8)', size = 64, shape = 'radial') => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    if (shape === 'radial') {
                        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                    } else { // simple square, less ideal for particles
                        ctx.fillStyle = color;
                    }
                    ctx.fillRect(0,0,size,size);
                    return new THREE.CanvasTexture(canvas);
                };

                // Using placeholder textures. Replace with textureLoader.load for your own images.
                starTexture = createPlaceholderTexture('rgba(230,230,255,0.9)', 32);
                cloudTexture = createPlaceholderTexture('rgba(200,200,220,0.2)', 128); // Cloud particles often fainter
                fireflyTexture = createPlaceholderTexture('rgba(255,255,150,0.95)', 48);

                // Example of loading actual files (make sure files are in your repo and paths are correct):
                // const onTextureLoaded = () => { loadedCount++; if (loadedCount === totalToLoad) callback(); };
                // let loadedCount = 0; const totalToLoad = 3;
                // starTexture = textureLoader.load('./assets/sprites/soft_circle.png', onTextureLoaded, undefined, onTextureLoaded);
                // cloudTexture = textureLoader.load('./assets/sprites/wispy_cloud.png', onTextureLoaded, undefined, onTextureLoaded);
                // fireflyTexture = textureLoader.load('./assets/sprites/glow_dot.png', onTextureLoaded, undefined, onTextureLoaded);

                console.log("Textures initialized (placeholders).");
                callback(); // Call callback directly if using placeholders
            }

            const initMindAR = async () => {
                loadingMessage.innerHTML = "Initializing AR...<br>Point camera at the target image.";
                await startAudio(); // Attempt to start audio context and get permissions

                mindarThree = new MINDAR.IMAGE.MindARThree({
                    container: container,
                    // !!! CRITICAL: Replace with the path to YOUR .mind file in your repository !!!
                    imageTargetSrc: "./targets.mind",
                    maxTrack: 1,
                    uiLoading: "no", // We have our own loading message
                    uiScanning: "no",// "yes" can be useful for visual feedback
                    uiError: "yes"
                });
                const { renderer, scene, camera } = mindarThree;
                anchor = mindarThree.addAnchor(0);

                anchor.onTargetFound = () => {
                    console.log("Target Found!");
                    loadingMessage.style.display = 'none'; // Hide loading message on target found
                     if (currentVisualType === 'none' && !currentVisual) { // Auto-start a visual if none active
                        setActiveVisual('starfield');
                    }
                };
                anchor.onTargetLost = () => {
                    console.log("Target Lost.");
                    // Optionally, show a "Target Lost" message or pause visuals
                    // loadingMessage.innerHTML = "Target lost. Please find the image again.";
                    // loadingMessage.style.display = 'block';
                };


                await mindarThree.start();
                renderer.setAnimationLoop(() => {
                    const delta = clock.getDelta();
                    const elapsedTime = clock.elapsedTime;
                    const currentAudioData = updateAudioSummary(); // Get fresh audio data

                    if (anchor.visible && currentVisual && currentVisual.update) {
                        currentVisual.update(currentAudioData, elapsedTime, delta);
                    }
                    renderer.render(scene, camera);
                });
            };

            function clearVisuals() {
                if (currentVisual && currentVisual.mesh) {
                    anchor.group.remove(currentVisual.mesh);
                    if (currentVisual.mesh.geometry) currentVisual.mesh.geometry.dispose();
                    if (currentVisual.mesh.material) {
                        if (Array.isArray(currentVisual.mesh.material)) {
                            currentVisual.mesh.material.forEach(m => m.dispose());
                        } else {
                            currentVisual.mesh.material.dispose();
                        }
                    }
                    if (currentVisual.textures) { // Dispose any dynamically created textures for a visual
                        currentVisual.textures.forEach(tex => tex.dispose());
                    }
                    console.log("Cleared visual:", currentVisual.type);
                }
                currentVisual = null;
            }

            window.setActiveVisual = (type) => {
                if (currentVisualType === type && type !== 'none') return; // Avoid re-creating same visual unless it's 'none'

                clearVisuals();
                currentVisualType = type;

                controlButtons.forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(`btn-${type}`);
                if (activeBtn) activeBtn.classList.add('active');


                switch (type) {
                    case 'starfield': createStarField(); break;
                    case 'clouds': createClouds(); break;
                    case 'water': createFlowingWater(); break;
                    case 'fireflies': createFireflies(); break;
                    case 'none': console.log("Visuals cleared by user."); break;
                }
                if (currentVisual) console.log("Set active visual:", currentVisual.type);
            };

            // --- Visual Effect Functions ---

            // --- 1. Star Field ---
            function createStarField() {
                const particleCount = 2500; // Adjusted for performance
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 30; // X (wider spread)
                    positions[i * 3 + 1] = Math.random() * 15 + 5;    // Y (5 to 20 units above anchor)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 30 - 8; // Z (depth, slightly back)

                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.1 + 0.58, 0.9, Math.random() * 0.35 + 0.6); // Cool whites, pale blues
                    colors[i * 3 + 0] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.07, map: starTexture, vertexColors: true,
                    transparent: true, blending: THREE.AdditiveBlending,
                    sizeAttenuation: true, depthWrite: false, opacity: 0.85
                });

                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'starfield',
                    update: (audioData, time) => {
                        points.material.opacity = 0.6 + (audioData.trebleAverage / 255) * 0.4;
                        points.rotation.y += 0.0003; // Slow cosmic rotation
                    }
                };
            }

            // --- 2. Clouds (Particle Based) ---
            function createClouds() {
                const particleCount = 150; // Fewer, larger particles
                const positions = new Float32Array(particleCount * 3);
                const cloudInstanceData = [];

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 20; // X spread
                    positions[i * 3 + 1] = Math.random() * 5 + 7;    // Y: 7 to 12 units high
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 15 - 10; // Z depth
                    cloudInstanceData.push({
                        driftX: (Math.random() - 0.5) * 0.008,
                        driftZ: (Math.random() - 0.5) * 0.003,
                        baseScale: Math.random() * 5 + 4 // Random base size for cloud particles
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: cloudInstanceData[0].baseScale, // Will be dynamic if needed, or set per particle via shader
                    map: cloudTexture, transparent: true, opacity: 0.20,
                    blending: THREE.NormalBlending, depthWrite: false, color: 0xf0f8ff // AliceBlue tint
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'clouds', data: cloudInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioInfluence = audioData.midAverage / 255;
                        material.opacity = 0.15 + (audioData.overallAverage / 255) * 0.25;
                        // material.size = 6 + audioInfluence * 4; // Global size change

                        for (let i = 0; i < particleCount; i++) {
                            posAttr.array[i * 3 + 0] += (currentVisual.data[i].driftX + audioInfluence * 0.002) * (delta * 60);
                            posAttr.array[i * 3 + 2] += (currentVisual.data[i].driftZ + audioInfluence * 0.001) * (delta * 60);
                            if (posAttr.array[i * 3 + 0] > 12) posAttr.array[i * 3 + 0] = -12;
                            if (posAttr.array[i * 3 + 0] < -12) posAttr.array[i * 3 + 0] = 12;
                        }
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- 3. Flowing Water (Shader on a Plane) ---
            // (Shader code needs to be robust and tested)
            const waterVertexShader = `
                varying vec2 vUv;
                uniform float uTime;
                uniform float uFrequency;
                uniform float uAmplitude;
                // Psuedo-random generator
                float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
                // Perlin-like noise
                float noise(vec2 p) {
                    vec2 i = floor(p); vec2 f = fract(p);
                    f = f*f*(3.0-2.0*f); // Smoothstep
                    float r1 = mix(rand(i), rand(i + vec2(1.0,0.0)),f.x);
                    float r2 = mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)),f.x);
                    return mix(r1,r2,f.y);
                }
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float time = uTime * 0.15; // Slower time for water
                    pos.z += sin(pos.x * uFrequency + time) * uAmplitude * 0.6;
                    pos.z += cos(pos.y * uFrequency * 0.7 + time * 1.3) * uAmplitude * 0.4;
                    pos.z += noise(vec2(pos.x * 0.15 + time * 0.2, pos.y * 0.15 + time * 0.1)) * uAmplitude * 0.8;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }`;
            const waterFragmentShader = `
                varying vec2 vUv;
                uniform float uTime;
                uniform vec3 uWaterColorDeep;
                uniform vec3 uWaterColorSurface;
                uniform float uOpacity;
                // Psuedo-random generator
                float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
                // Perlin-like noise
                float noise(vec2 p) {
                    vec2 i = floor(p); vec2 f = fract(p);
                    f = f*f*(3.0-2.0*f); // Smoothstep
                    float r1 = mix(rand(i), rand(i + vec2(1.0,0.0)),f.x);
                    float r2 = mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)),f.x);
                    return mix(r1,r2,f.y);
                }
                void main() {
                    float time = uTime * 0.03;
                    vec2 uvT = vUv;
                    uvT.x += noise(vUv * 2.5 + time) * 0.02; // Ripple distortion
                    uvT.y += noise(vUv * 2.5 - time * 1.2) * 0.02;
                    float n = abs(noise(uvT * 5.0 + time * 0.6)); // Base noise for color
                    vec3 waterColor = mix(uWaterColorDeep, uWaterColorSurface, smoothstep(0.25, 0.65, n));
                    float sparkleN = noise(vUv * 20.0 + time * 2.5); // Noise for sparkles
                    float sparkle = pow(max(0.0, sparkleN - 0.6), 6.0) * 0.8; // Sharp sparkles
                    sparkle = smoothstep(0.0, 0.1, sparkle);
                    gl_FragColor = vec4(waterColor + sparkle, (n * 0.35 + 0.45) * uOpacity);
                }`;

            function createFlowingWater() {
                const geometry = new THREE.PlaneGeometry(15, 15, 50, 50); // Plane size and segments
                const material = new THREE.ShaderMaterial({
                    vertexShader: waterVertexShader, fragmentShader: waterFragmentShader,
                    uniforms: {
                        uTime: { value: 0.0 },
                        uFrequency: { value: 2.5 }, // How dense the waves are
                        uAmplitude: { value: 0.2 }, // How high the waves are
                        uWaterColorDeep: { value: new THREE.Color(0x001e42) }, // Dark blue
                        uWaterColorSurface: { value: new THREE.Color(0x30a0f0) }, // Lighter blue
                        uOpacity: { value: 0.65 }
                    },
                    transparent: true, depthWrite: false, side: THREE.DoubleSide
                });
                const waterMesh = new THREE.Mesh(geometry, material);
                waterMesh.position.y = 4; // Height of the water effect
                waterMesh.rotation.x = -Math.PI / 2.8; // Tilt it to be more like an aurora/sheet
                anchor.group.add(waterMesh);
                currentVisual = {
                    mesh: waterMesh, type: 'water',
                    update: (audioData, time) => {
                        material.uniforms.uTime.value = time;
                        material.uniforms.uFrequency.value = 1.5 + (audioData.midAverage / 255) * 5.0;
                        material.uniforms.uAmplitude.value = 0.05 + (audioData.bassAverage / 255) * 0.45;
                        material.uniforms.uOpacity.value = 0.4 + (audioData.overallAverage / 255) * 0.45;
                    }
                };
            }

            // --- 4. Fireflies ---
            function createFireflies() {
                const particleCount = 70; // Fewer, more distinct
                const positions = new Float32Array(particleCount * 3);
                const fireflyInstanceData = [];

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 12; // X spread
                    positions[i * 3 + 1] = Math.random() * 5 + 1;    // Y (1 to 6 units high)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 12 - 3; // Z depth
                    fireflyInstanceData.push({
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.005, (Math.random()-0.5)*0.01),
                        blinkOffset: Math.random() * Math.PI * 2,
                        targetY: positions[i * 3 + 1]
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.22, map: fireflyTexture, color: 0xffffaa, // Warm yellow
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'fireflies', data: fireflyInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioLevel = audioData.overallAverage / 255;
                        let collectiveOpacity = 0;

                        for (let i = 0; i < particleCount; i++) {
                            const ff = currentVisual.data[i];
                            // Movement
                            posAttr.array[i * 3 + 0] += ff.velocity.x * (1 + audioLevel * 0.5) * (delta * 60);
                            posAttr.array[i * 3 + 1] += ff.velocity.y * (1 + audioLevel * 0.2) * (delta * 60);
                            posAttr.array[i * 3 + 2] += ff.velocity.z * (1 + audioLevel * 0.5) * (delta * 60);

                            // Gentle drift towards original Y height
                            ff.velocity.y += (ff.targetY - posAttr.array[i * 3 + 1]) * 0.0005;
                            ff.velocity.multiplyScalar(0.98); // Dampening

                            if (Math.random() < 0.02) { // Randomly change target velocity slightly
                                ff.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.005, (Math.random()-0.5)*0.003, (Math.random()-0.5)*0.005));
                            }
                            // Boundaries (soft reflection)
                            if (Math.abs(posAttr.array[i*3+0]) > 7) ff.velocity.x *= -0.9;
                            if (posAttr.array[i*3+1] < 0.5 || posAttr.array[i*3+1] > 7) ff.velocity.y *= -0.9;
                            if (Math.abs(posAttr.array[i*3+2]) > 7) ff.velocity.z *= -0.9;

                            // Blinking contribution to collective opacity
                            const blink = Math.sin(time * (1.5 + audioLevel*2.0) + ff.blinkOffset) + Math.sin(time*0.6 + ff.blinkOffset*0.7);
                            if (blink > 0.9) { // If this firefly is "on"
                                collectiveOpacity += ( (blink - 0.9) / 1.1 ) * (0.6 + audioLevel * 0.4);
                            }
                        }
                        material.opacity = Math.min(1.0, collectiveOpacity / (particleCount * 0.15)); // Average out opacity based on how many are lit
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // Start the experience
            loadAllAssets(() => {
                 // Check if MindAR is available
                if (typeof MINDAR === 'undefined' || typeof MINDAR.IMAGE === 'undefined') {
                    loadingMessage.innerHTML = "Error: MindAR library not loaded correctly. Check script tags.";
                    console.error("MindAR library not loaded.");
                    return;
                }
                initMindAR().catch(err => {
                     loadingMessage.innerHTML = "Failed to initialize AR: <br><small>" + err.message + "</small>";
                     console.error("Failed to initialize AR:", err);
                });
            });
        });
    </script>
</body>
</html>

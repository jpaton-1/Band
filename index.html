<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Concert AR Visuals</title>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.164.1/three.min.js"></script>
    <style>
        body { margin: 0; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        #controls button { display: block; margin: 5px; padding: 8px; color: white; background-color: #333; border: none; cursor: pointer; }
        #controls button:hover { background-color: #555; }
        #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5em; text-align: center;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="loadingMessage">Loading Assets and Starting AR... Please Allow Camera.</div>
    <div id="controls">
        <button onclick="setActiveVisual('starfield')">Star Field</button>
        <button onclick="setActiveVisual('clouds')">Clouds</button>
        <button onclick="setActiveVisual('water')">Flowing Water</button>
        <button onclick="setActiveVisual('fireflies')">Fireflies</button>
        <button onclick="setActiveVisual('none')">Clear Visuals</button>
    </div>
    <div id="container"></div>

    <script>
        // Ensure DOM is loaded before scripts run
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector("#container");
            const loadingMessage = document.getElementById('loadingMessage');
            let mindarThree;
            let anchor;
            let currentVisual = null;
            const clock = new THREE.Clock();

            // Audio analysis (simplified placeholder - integrate your actual Web Audio API setup here)
            let analyser;
            let dataArray;
            const audioSummary = { overallAverage: 0, bassAverage: 0, midAverage: 0, trebleAverage: 0, dataArrayValid: false };

            async function startAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    audioSummary.dataArrayValid = true;
                    console.log("Microphone access granted and audio analyser set up.");
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    loadingMessage.innerHTML = "Microphone access denied. Audio reactivity will not work. <br>" + err.message;
                    // No need to hide loading message if mic fails, just update it.
                }
            }

            function getAudioSummary() {
                if (!analyser || !dataArray || !audioSummary.dataArrayValid) {
                    return { overallAverage: 30, bassAverage: 30, midAverage: 30, trebleAverage: 30 }; // Default if no audio
                }
                analyser.getByteFrequencyData(dataArray);
                let overallSum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const len = dataArray.length;
                const bassCutoff = Math.floor(len * 0.2); // First 20% for bass
                const midCutoff = Math.floor(len * 0.6);  // Next 40% for mid

                for (let i = 0; i < len; i++) {
                    const val = dataArray[i];
                    overallSum += val;
                    if (i < bassCutoff) bassSum += val;
                    else if (i < midCutoff) midSum += val;
                    else trebleSum += val;
                }
                audioSummary.overallAverage = overallSum / len;
                audioSummary.bassAverage = bassCutoff > 0 ? bassSum / bassCutoff : 0;
                audioSummary.midAverage = (midCutoff - bassCutoff) > 0 ? midSum / (midCutoff - bassCutoff) : 0;
                audioSummary.trebleAverage = (len - midCutoff) > 0 ? trebleSum / (len - midCutoff) : 0;
                return audioSummary;
            }


            // --- Texture Loading ---
            const textureLoader = new THREE.TextureLoader();
            let starTexture, cloudTexture, fireflyTexture;

            function loadTextures(callback) {
                let texturesToLoad = 3;
                let texturesLoaded = 0;
                const onTextureLoaded = () => {
                    texturesLoaded++;
                    if (texturesLoaded === texturesToLoad) {
                        callback();
                    }
                };
                // Replace with paths to your actual small sprite PNGs
                // For now, we create placeholder data URLs for basic dots if real images aren't available.
                const createPlaceholderTexture = (color = 'white', size = 64) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0,0,size,size);
                    return new THREE.CanvasTexture(canvas);
                };

                starTexture = createPlaceholderTexture('rgba(255,255,255,0.8)'); // Placeholder
                cloudTexture = createPlaceholderTexture('rgba(200,200,220,0.3)', 128); // Placeholder
                fireflyTexture = createPlaceholderTexture('rgba(255,255,100,0.9)'); // Placeholder

                // Example with actual files (comment out placeholders above if using these)
                // starTexture = textureLoader.load('path/to/soft_circle.png', onTextureLoaded, undefined, onTextureLoaded);
                // cloudTexture = textureLoader.load('path/to/wispy_cloud_particle.png', onTextureLoaded, undefined, onTextureLoaded);
                // fireflyTexture = textureLoader.load('path/to/glow_dot.png', onTextureLoaded, undefined, onTextureLoaded);
                onTextureLoaded(); onTextureLoaded(); onTextureLoaded(); // Call if using placeholders
            }


            const initMindAR = async () => {
                await startAudio(); // Request microphone access first

                mindarThree = new MINDAR.IMAGE.MindARThree({
                    container: container,
                    // Replace with the path to YOUR .mind file
                    imageTargetSrc: "./targets.mind",
                    maxTrack: 1
                });
                const { renderer, scene, camera } = mindarThree;
                anchor = mindarThree.addAnchor(0);

                loadingMessage.style.display = 'none'; // Hide loading message

                await mindarThree.start();
                renderer.setAnimationLoop(() => {
                    const delta = clock.getDelta();
                    const elapsedTime = clock.elapsedTime;
                    const currentAudio = getAudioSummary();

                    if (currentVisual && currentVisual.update) {
                        currentVisual.update(currentAudio, elapsedTime, delta);
                    }
                    renderer.render(scene, camera);
                });
            };

            function clearVisuals() {
                if (currentVisual && currentVisual.mesh) {
                    anchor.group.remove(currentVisual.mesh);
                    if (currentVisual.mesh.geometry) currentVisual.mesh.geometry.dispose();
                    if (currentVisual.mesh.material) {
                        if (Array.isArray(currentVisual.mesh.material)) {
                            currentVisual.mesh.material.forEach(m => m.dispose());
                        } else {
                            currentVisual.mesh.material.dispose();
                        }
                    }
                    // Dispose any custom textures associated with the visual
                    if (currentVisual.textures) {
                        currentVisual.textures.forEach(tex => tex.dispose());
                    }
                }
                currentVisual = null;
            }

            window.setActiveVisual = (type) => {
                clearVisuals();
                switch (type) {
                    case 'starfield': createStarField(); break;
                    case 'clouds': createClouds(); break;
                    case 'water': createFlowingWater(); break;
                    case 'fireflies': createFireflies(); break;
                    case 'none': /* Already cleared */ break;
                }
            };

            // --- 1. Star Field ---
            function createStarField() {
                const particleCount = 3000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const opacities = new Float32Array(particleCount); // Per-particle opacity for twinkling

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 25; // X
                    positions[i * 3 + 1] = Math.random() * 10 + 5;    // Y (5 to 15 units above anchor)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 25 - 5; // Z (some depth)

                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.1 + 0.55, 0.8, Math.random() * 0.4 + 0.6); // Cool whites, pale blues
                    colors[i * 3 + 0] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    opacities[i] = Math.random() * 0.5 + 0.3; // Initial random opacity
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('alpha', new THREE.BufferAttribute(opacities, 1));


                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    map: starTexture,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                 // For per-particle alpha, you need a custom shader. This is a simplified approach.
                 // A simple global opacity for now:
                material.opacity = 0.8;


                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points,
                    type: 'starfield',
                    update: (audioData, time) => {
                        // Simple global twinkle based on audio
                        points.material.opacity = 0.5 + (audioData.trebleAverage / 255) * 0.5;
                        points.rotation.y += 0.0005; // Slow rotation of the field
                    }
                };
            }

            // --- 2. Clouds (Particle Based) ---
            function createClouds() {
                const particleCount = 200; // Fewer, larger particles
                const positions = new Float32Array(particleCount * 3);
                const cloudData = []; // Store individual drift speeds

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 15;
                    positions[i * 3 + 1] = Math.random() * 4 + 6; // Y: 6 to 10 units high
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 10 - 8; // Closer to camera, less depth
                    cloudData.push({ driftX: (Math.random() - 0.5) * 0.005, driftZ: (Math.random() - 0.5) * 0.002 });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: 8.0, // Large, soft particles
                    map: cloudTexture,
                    transparent: true,
                    opacity: 0.25, // Quite transparent
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    color: 0xffffff // Tint if texture is B&W
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points,
                    type: 'clouds',
                    data: cloudData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioInfluence = audioData.midAverage / 255;
                        material.opacity = 0.15 + audioData.overallAverage / 255 * 0.3;

                        for (let i = 0; i < particleCount; i++) {
                            posAttr.array[i * 3 + 0] += (currentVisual.data[i].driftX + audioInfluence * 0.001) * (delta * 60); // Adjust speed by delta
                            posAttr.array[i * 3 + 2] += (currentVisual.data[i].driftZ + audioInfluence * 0.0005) * (delta * 60);
                            // Loop particles
                            if (posAttr.array[i * 3 + 0] > 10) posAttr.array[i * 3 + 0] = -10;
                            if (posAttr.array[i * 3 + 0] < -10) posAttr.array[i * 3 + 0] = 10;
                        }
                        posAttr.needsUpdate = true;
                    }
                };
            }

            // --- 3. Flowing Water (Shader on a Plane) ---
            const waterVertexShader = `
                varying vec2 vUv;
                uniform float uTime;
                uniform float uFrequency;
                uniform float uAmplitude;

                // Basic Perlin 2D noise for organic look
                float pNoise(vec2 p, float rep) {
                    vec2 ip = floor(p * rep);
                    vec2 fp = fract(p * rep);
                    float term1 = sin(dot(ip, vec2(12.9898, 78.233)) + ip.x * ip.y * 15.543);
                    float term2 = sin(dot(ip + vec2(1.0,0.0), vec2(12.9898, 78.233)) + (ip.x+1.0) * ip.y * 15.543);
                    float term3 = sin(dot(ip + vec2(0.0,1.0), vec2(12.9898, 78.233)) + ip.x * (ip.y+1.0) * 15.543);
                    float term4 = sin(dot(ip + vec2(1.0,1.0), vec2(12.9898, 78.233)) + (ip.x+1.0) * (ip.y+1.0) * 15.543);
                    vec2 t = smoothstep(0.0, 1.0, fp);
                    return mix(mix(term1, term2, t.x), mix(term3, term4, t.x), t.y);
                }


                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float time = uTime * 0.2;
                    pos.z += sin(pos.x * uFrequency + time) * uAmplitude * 0.5;
                    pos.z += cos(pos.y * uFrequency * 0.8 + time * 1.2) * uAmplitude * 0.3;
                    pos.z += pNoise(vec2(pos.x * 0.2, pos.y * 0.2) + time * 0.1, 5.0) * uAmplitude * 0.6;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }`;
            const waterFragmentShader = `
                varying vec2 vUv;
                uniform float uTime;
                uniform vec3 uWaterColorDeep;
                uniform vec3 uWaterColorSurface;
                uniform float uOpacity;

                float pNoise(vec2 p, float rep) { /* ... copy pNoise from vertex ... */
                    vec2 ip = floor(p * rep); vec2 fp = fract(p * rep);
                    float term1 = sin(dot(ip, vec2(12.9898, 78.233)) + ip.x * ip.y * 15.543);
                    float term2 = sin(dot(ip + vec2(1.0,0.0), vec2(12.9898, 78.233)) + (ip.x+1.0) * ip.y * 15.543);
                    float term3 = sin(dot(ip + vec2(0.0,1.0), vec2(12.9898, 78.233)) + ip.x * (ip.y+1.0) * 15.543);
                    float term4 = sin(dot(ip + vec2(1.0,1.0), vec2(12.9898, 78.233)) + (ip.x+1.0) * (ip.y+1.0) * 15.543);
                    vec2 t = smoothstep(0.0, 1.0, fp);
                    return mix(mix(term1, term2, t.x), mix(term3, term4, t.x), t.y);
                }

                void main() {
                    float time = uTime * 0.05;
                    vec2 uvT = vUv;
                    uvT.x += pNoise(vUv * 2.0 + time, 10.0) * 0.03;
                    uvT.y += pNoise(vUv * 2.0 - time, 10.0) * 0.03;
                    float n = abs(pNoise(uvT * 4.0 + time * 0.5, 8.0));
                    vec3 waterColor = mix(uWaterColorDeep, uWaterColorSurface, smoothstep(0.2, 0.6, n));
                    float sparkle = pow(abs(pNoise(vUv * 15.0 + time * 1.5, 15.0)), 8.0);
                    sparkle = smoothstep(0.7, 0.9, sparkle) * 0.7;
                    gl_FragColor = vec4(waterColor + sparkle, (n * 0.4 + 0.5) * uOpacity);
                }`;

            function createFlowingWater() {
                const geometry = new THREE.PlaneGeometry(12, 12, 60, 60); // More segments for smoother waves
                // geometry.rotateX(-Math.PI / 2.5); // Tilted like an aurora or sheet
                const material = new THREE.ShaderMaterial({
                    vertexShader: waterVertexShader,
                    fragmentShader: waterFragmentShader,
                    uniforms: {
                        uTime: { value: 0.0 },
                        uFrequency: { value: 3.0 },
                        uAmplitude: { value: 0.15 },
                        uWaterColorDeep: { value: new THREE.Color(0x002060) },
                        uWaterColorSurface: { value: new THREE.Color(0x60a0ff) },
                        uOpacity: { value: 0.5 }
                    },
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                const waterMesh = new THREE.Mesh(geometry, material);
                waterMesh.position.y = 5; // Position it in the air
                waterMesh.rotation.x = -Math.PI / 3; // Tilt it
                anchor.group.add(waterMesh);
                currentVisual = {
                    mesh: waterMesh, type: 'water',
                    update: (audioData, time) => {
                        material.uniforms.uTime.value = time;
                        material.uniforms.uFrequency.value = 2.0 + (audioData.midAverage / 255) * 6.0;
                        material.uniforms.uAmplitude.value = 0.05 + (audioData.bassAverage / 255) * 0.35;
                        material.uniforms.uOpacity.value = 0.3 + (audioData.overallAverage / 255) * 0.5;
                    }
                };
            }

            // --- 4. Fireflies ---
            function createFireflies() {
                const particleCount = 80;
                const positions = new Float32Array(particleCount * 3);
                const fireflyData = [];

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 10; // X
                    positions[i * 3 + 1] = Math.random() * 4 + 1.5;   // Y (1.5 to 5.5 units high)
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 10 - 2; // Z
                    fireflyData.push({
                        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.008, (Math.random() - 0.5) * 0.004, (Math.random() - 0.5) * 0.008),
                        blinkOffset: Math.random() * Math.PI * 2,
                        baseIntensity: Math.random() * 0.5 + 0.5
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.25, map: fireflyTexture, color: 0xffffaa,
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'fireflies', data: fireflyData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioLevel = audioData.overallAverage / 255;
                        material.opacity = 0; // Will be set by blink

                        for (let i = 0; i < particleCount; i++) {
                            const ff = currentVisual.data[i];
                            posAttr.array[i * 3 + 0] += ff.velocity.x * (1 + audioLevel) * (delta * 60);
                            posAttr.array[i * 3 + 1] += ff.velocity.y * (1 + audioLevel) * (delta * 60);
                            posAttr.array[i * 3 + 2] += ff.velocity.z * (1 + audioLevel) * (delta * 60);

                            if (Math.random() < 0.01) { // Occasionally change direction
                                ff.velocity.set((Math.random() - 0.5) * 0.008, (Math.random() - 0.5) * 0.004, (Math.random() - 0.5) * 0.008);
                            }
                            // Boundaries
                            if (Math.abs(posAttr.array[i*3+0]) > 6) ff.velocity.x *= -0.8;
                            if (posAttr.array[i*3+1] < 1 || posAttr.array[i*3+1] > 6) ff.velocity.y *= -0.8;
                            if (Math.abs(posAttr.array[i*3+2]) > 6) ff.velocity.z *= -0.8;

                            // Blinking - apply to global opacity for simplicity without complex shader
                            const blink = Math.sin(time * 2.0 + ff.blinkOffset) + Math.sin(time*0.7 + ff.blinkOffset*0.5); // Compound sine
                            if (blink > 0.8) { // Make material.opacity an average of blinking fireflies
                                material.opacity = Math.max(material.opacity, ff.baseIntensity * (0.5 + audioLevel * 0.5) * ((blink - 0.8)/1.2) );
                            }
                        }
                        if(particleCount > 0) material.opacity = Math.min(1, material.opacity + 0.1); // ensure some base if many are off
                        else material.opacity = 0;

                        posAttr.needsUpdate = true;
                    }
                };
            }

            // Start everything
            loadTextures(initMindAR);
        });
    </script>
</body>
</html>

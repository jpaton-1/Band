<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>A Band After Midnight - AR Experience</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px;
            display: none; /* Initially hidden */
        }
        #controls button {
            display: block;
            margin: 6px;
            padding: 10px 12px;
            color: white;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover { background-color: #666; }
        #controls button.active { background-color: #007bff; border-color: #0056b3;}

        #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5em; text-align: center;
            background: rgba(0,0,0,0.75); padding: 25px; border-radius: 10px;
            z-index: 200;
            display: none; /* Initially hidden */
        }

        #startExperienceUI {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 300; text-align: center; background: rgba(0,0,0,0.85);
            padding: 30px; border-radius: 15px; max-width: 90%; box-sizing: border-box;
        }
        #startExperienceUI h2 { margin-top: 0; color: #00aaff; }
        #startExperienceUI p { font-size: 1.1em; margin-bottom: 25px; line-height: 1.5; }
        #startArButton {
            padding: 15px 30px; font-size: 1.25em; cursor: pointer;
            background-color: #007bff; color: white; border: none;
            border-radius: 8px; font-weight: bold;
            transition: background-color 0.3s ease;
        }
        #startArButton:hover { background-color: #0056b3; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.164.1/three.module.min.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
        "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
      }
    }
    </script>
</head>
<body>
    <div id="startExperienceUI">
        <h2>Welcome to the AR Visualizer!</h2>
        <p>
            This experience uses your device's camera for Augmented Reality
            and your microphone to make the visuals react to sound.
            <br><br>
            Please click "Start" and then <strong>allow camera and microphone access</strong> when your browser asks.
        </p>
        <button id="startArButton">Start AR Experience</button>
    </div>

    <div id="loadingMessage">Loading AR Experience...</div>
    <div id="controls">
        <button id="btn-starfield" onclick="setActiveVisual('starfield')">Star Field</button>
        <button id="btn-clouds" onclick="setActiveVisual('clouds')">Clouds</button>
        <button id="btn-water" onclick="setActiveVisual('water')">Flowing Water</button>
        <button id="btn-fireflies" onclick="setActiveVisual('fireflies')">Fireflies</button>
        <button id="btn-none" onclick="setActiveVisual('none')">Clear Visuals</button>
    </div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { MindARThree } from 'mindar-image-three';

        // Optional: If CSS3DRenderer is explicitly needed by your own code later, you would import it like this:
        // import { CSS3DRenderer } from 'three/addons/renderers/CSS3DRenderer.js';

        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector("#container");
            const loadingMessage = document.getElementById('loadingMessage');
            const controlsDiv = document.getElementById('controls');
            const startExperienceUI = document.getElementById('startExperienceUI');
            const startArButton = document.getElementById('startArButton');

            let mindarThree;
            let anchor;
            let currentVisual = null;
            let currentVisualType = 'none';
            const clock = new THREE.Clock();

            let analyser;
            let dataArray;
            const audioSummary = {
                overallAverage: 0, bassAverage: 0, midAverage: 0, trebleAverage: 0,
                dataArrayValid: false, audioContextActive: false
            };

            async function startAudio() {
                if (audioSummary.audioContextActive) return;
                if(loadingMessage) loadingMessage.innerHTML = "Requesting microphone access...";
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.7;
                    source.connect(analyser);
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    audioSummary.dataArrayValid = true;
                    audioSummary.audioContextActive = true;
                    console.log("Microphone access granted. Audio analyser active.");
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    if(loadingMessage) loadingMessage.innerHTML = "Microphone access denied/error. Audio reactivity disabled.<br><small>" + err.message + "</small>";
                }
            }

            function updateAudioSummary() {
                if (!analyser || !dataArray || !audioSummary.dataArrayValid) {
                    audioSummary.overallAverage = 10; audioSummary.bassAverage = 10;
                    audioSummary.midAverage = 10; audioSummary.trebleAverage = 10;
                    return audioSummary;
                }
                analyser.getByteFrequencyData(dataArray);
                let overallSum = 0, bassSum = 0, midSum = 0, trebleSum = 0;
                const len = dataArray.length;
                const bassCutoff = Math.floor(len * 0.15);
                const midCutoff = Math.floor(len * 0.50);

                for (let i = 0; i < len; i++) {
                    const val = dataArray[i];
                    overallSum += val;
                    if (i < bassCutoff) bassSum += val;
                    else if (i < midCutoff) midSum += val;
                    else trebleSum += val;
                }
                audioSummary.overallAverage = overallSum / len || 0;
                audioSummary.bassAverage = bassCutoff > 0 ? bassSum / bassCutoff : 0;
                audioSummary.midAverage = (midCutoff - bassCutoff) > 0 ? midSum / (midCutoff - bassCutoff) : 0;
                audioSummary.trebleAverage = (len - midCutoff) > 0 ? trebleSum / (len - midCutoff) : 0;
                return audioSummary;
            }

            const textureLoader = new THREE.TextureLoader();
            let starTexture, cloudTexture, fireflyTexture;

            function loadAllAssets(callback) {
                if(loadingMessage) loadingMessage.innerHTML = "Loading textures...";
                const createPlaceholderTexture = (color = 'rgba(255,255,255,0.8)', size = 64, shape = 'radial') => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    if (shape === 'radial') {
                        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                    } else { ctx.fillStyle = color; }
                    ctx.fillRect(0,0,size,size);
                    return new THREE.CanvasTexture(canvas);
                };

                starTexture = createPlaceholderTexture('rgba(230,230,255,0.9)', 32);
                cloudTexture = createPlaceholderTexture('rgba(200,200,220,0.2)', 128);
                fireflyTexture = createPlaceholderTexture('rgba(255,255,150,0.95)', 48);
                console.log("Textures initialized (using placeholders).");
                callback();
            }

            const initMindAR = async () => {
                if(loadingMessage) loadingMessage.innerHTML = "Initializing AR...<br>Please allow camera access and point at the target image.";
                
                await startAudio();

                mindarThree = new MindARThree({
                    container: container,
                    imageTargetSrc: "./targets.mind",
                    maxTrack: 1,
                    uiLoading: "no", uiScanning: "no", uiError: "yes"
                });
                const { renderer, scene, camera } = mindarThree;
                anchor = mindarThree.addAnchor(0);

                anchor.onTargetFound = () => {
                    console.log("Target Found!");
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    if (currentVisualType === 'none' && !currentVisual) {
                        setActiveVisual('starfield');
                    }
                };
                anchor.onTargetLost = () => {
                    console.log("Target Lost.");
                };

                try {
                    await mindarThree.start();
                    renderer.setAnimationLoop(() => {
                        const delta = clock.getDelta();
                        const elapsedTime = clock.getElapsedTime();
                        const currentAudioData = updateAudioSummary();

                        if (anchor.visible && currentVisual && currentVisual.update) {
                            currentVisual.update(currentAudioData, elapsedTime, delta);
                        }
                        renderer.render(scene, camera);
                    });
                } catch (e) {
                    console.error("Error starting MindAR:", e);
                    if(loadingMessage) loadingMessage.innerHTML = "Error starting AR. Check console, permissions, and target file.<br><small>" + e.message + "</small>";
                }
            };

            function clearVisuals() {
                if (anchor && currentVisual && currentVisual.mesh) {
                    anchor.group.remove(currentVisual.mesh);
                    if (currentVisual.mesh.geometry) currentVisual.mesh.geometry.dispose();
                    if (currentVisual.mesh.material) {
                        if (Array.isArray(currentVisual.mesh.material)) {
                            currentVisual.mesh.material.forEach(m => m.dispose());
                        } else {
                            currentVisual.mesh.material.dispose();
                        }
                    }
                    if (currentVisual.textures) {
                        currentVisual.textures.forEach(tex => tex.dispose());
                    }
                    console.log("Cleared visual:", currentVisual.type);
                }
                currentVisual = null;
            }
            
            window.setActiveVisual = (type) => {
                if (currentVisualType === type && type !== 'none' && currentVisual) return;

                clearVisuals();
                currentVisualType = type;

                document.querySelectorAll('#controls button').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(`btn-${type}`);
                if (activeBtn) activeBtn.classList.add('active');

                if (!anchor && type !== 'none') {
                    console.warn("AR anchor not ready, cannot create visual: " + type);
                    if(loadingMessage && loadingMessage.style.display === 'none') {
                        loadingMessage.innerHTML = "AR not fully loaded. Try finding the target again.";
                        loadingMessage.style.display = 'block';
                    }
                    return;
                }
                
                switch (type) {
                    case 'starfield': createStarField(); break;
                    case 'clouds': createClouds(); break;
                    case 'water': createFlowingWater(); break;
                    case 'fireflies': createFireflies(); break;
                    case 'none': console.log("Visuals cleared by user."); break;
                }
                if (currentVisual) console.log("Set active visual:", currentVisual.type);
            };

            const shaderNoiseFunctions = `
                float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
                float noise(vec2 p) {
                    vec2 i = floor(p); vec2 f = fract(p);
                    f = f*f*(3.0-2.0*f);
                    float r1 = mix(rand(i), rand(i + vec2(1.0,0.0)),f.x);
                    float r2 = mix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)),f.x);
                    return mix(r1,r2,f.y);
                }
            `;

            function createStarField() {
                const particleCount = 2000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 30;
                    positions[i * 3 + 1] = Math.random() * 15 + 5;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 30 - 8;
                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.1 + 0.58, 0.9, Math.random() * 0.35 + 0.6);
                    colors[i * 3 + 0] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.07, map: starTexture, vertexColors: true,
                    transparent: true, blending: THREE.AdditiveBlending,
                    sizeAttenuation: true, depthWrite: false, opacity: 0.85
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'starfield',
                    update: (audioData, time) => {
                        points.material.opacity = 0.6 + (audioData.trebleAverage / 255) * 0.4;
                        points.rotation.y += 0.0003;
                    }
                };
            }

            function createClouds() {
                const particleCount = 120;
                const positions = new Float32Array(particleCount * 3);
                const cloudInstanceData = [];
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 1] = Math.random() * 5 + 7;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 15 - 10;
                    cloudInstanceData.push({ driftX: (Math.random() - 0.5) * 0.008, driftZ: (Math.random() - 0.5) * 0.003 });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 8.0, map: cloudTexture, transparent: true, opacity: 0.20,
                    blending: THREE.NormalBlending, depthWrite: false, color: 0xf0f8ff
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'clouds', data: cloudInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioInfluence = audioData.midAverage / 255;
                        material.opacity = 0.15 + (audioData.overallAverage / 255) * 0.25;
                        for (let i = 0; i < particleCount; i++) {
                            posAttr.array[i * 3 + 0] += (currentVisual.data[i].driftX + audioInfluence * 0.002) * (delta * 60);
                            posAttr.array[i * 3 + 2] += (currentVisual.data[i].driftZ + audioInfluence * 0.001) * (delta * 60);
                            if (posAttr.array[i * 3 + 0] > 12) posAttr.array[i * 3 + 0] = -12;
                            else if (posAttr.array[i * 3 + 0] < -12) posAttr.array[i * 3 + 0] = 12;
                        }
                        posAttr.needsUpdate = true;
                    }
                };
            }

            const waterVertexShader = shaderNoiseFunctions + `
                varying vec2 vUv; uniform float uTime; uniform float uFrequency; uniform float uAmplitude;
                void main() {
                    vUv = uv; vec3 pos = position; float time = uTime * 0.15;
                    pos.z += sin(pos.x * uFrequency + time) * uAmplitude * 0.6;
                    pos.z += cos(pos.y * uFrequency * 0.7 + time * 1.3) * uAmplitude * 0.4;
                    pos.z += noise(vec2(pos.x*0.15 + time*0.2, pos.y*0.15 + time*0.1)) * uAmplitude * 0.8;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }`;
            const waterFragmentShader = shaderNoiseFunctions + `
                varying vec2 vUv; uniform float uTime; uniform vec3 uWaterColorDeep; uniform vec3 uWaterColorSurface; uniform float uOpacity;
                void main() {
                    float time = uTime * 0.03; vec2 uvT = vUv;
                    uvT.x += noise(vUv * 2.5 + time) * 0.02; uvT.y += noise(vUv * 2.5 - time * 1.2) * 0.02;
                    float n = abs(noise(uvT * 5.0 + time * 0.6));
                    vec3 waterColor = mix(uWaterColorDeep, uWaterColorSurface, smoothstep(0.25, 0.65, n));
                    float sparkleN = noise(vUv * 20.0 + time * 2.5);
                    float sparkle = pow(max(0.0, sparkleN - 0.6), 6.0) * 0.8; sparkle = smoothstep(0.0, 0.1, sparkle);
                    gl_FragColor = vec4(waterColor + sparkle, (n * 0.35 + 0.45) * uOpacity);
                }`;

            function createFlowingWater() {
                const geometry = new THREE.PlaneGeometry(15, 15, 40, 40);
                const material = new THREE.ShaderMaterial({
                    vertexShader: waterVertexShader, fragmentShader: waterFragmentShader,
                    uniforms: {
                        uTime: { value: 0.0 }, uFrequency: { value: 2.5 }, uAmplitude: { value: 0.2 },
                        uWaterColorDeep: { value: new THREE.Color(0x001e42) },
                        uWaterColorSurface: { value: new THREE.Color(0x30a0f0) },
                        uOpacity: { value: 0.65 }
                    },
                    transparent: true, depthWrite: false, side: THREE.DoubleSide
                });
                const waterMesh = new THREE.Mesh(geometry, material);
                waterMesh.position.y = 4; waterMesh.rotation.x = -Math.PI / 2.8;
                anchor.group.add(waterMesh);
                currentVisual = {
                    mesh: waterMesh, type: 'water',
                    update: (audioData, time) => {
                        material.uniforms.uTime.value = time;
                        material.uniforms.uFrequency.value = 1.5 + (audioData.midAverage / 255) * 5.0;
                        material.uniforms.uAmplitude.value = 0.05 + (audioData.bassAverage / 255) * 0.45;
                        material.uniforms.uOpacity.value = 0.4 + (audioData.overallAverage / 255) * 0.45;
                    }
                };
            }

            function createFireflies() {
                const particleCount = 60;
                const positions = new Float32Array(particleCount * 3);
                const fireflyInstanceData = [];
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 12;
                    positions[i * 3 + 1] = Math.random() * 5 + 1;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 12 - 3;
                    fireflyInstanceData.push({
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.005, (Math.random()-0.5)*0.01),
                        blinkOffset: Math.random() * Math.PI * 2, targetY: positions[i * 3 + 1]
                    });
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    size: 0.22, map: fireflyTexture, color: 0xffffaa,
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9
                });
                const points = new THREE.Points(geometry, material);
                anchor.group.add(points);
                currentVisual = {
                    mesh: points, type: 'fireflies', data: fireflyInstanceData,
                    update: (audioData, time, delta) => {
                        const posAttr = points.geometry.getAttribute('position');
                        const audioLevel = audioData.overallAverage / 255;
                        let collectiveOpacity = 0;
                        for (let i = 0; i < particleCount; i++) {
                            const ff = currentVisual.data[i];
                            posAttr.array[i * 3 + 0] += ff.velocity.x * (1 + audioLevel*0.5) * (delta*60);
                            posAttr.array[i * 3 + 1] += ff.velocity.y * (1 + audioLevel*0.2) * (delta*60);
                            posAttr.array[i * 3 + 2] += ff.velocity.z * (1 + audioLevel*0.5) * (delta*60);
                            ff.velocity.y += (ff.targetY - posAttr.array[i * 3 + 1]) * 0.0005;
                            ff.velocity.multiplyScalar(0.98);
                            if (Math.random() < 0.02) ff.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.005, (Math.random()-0.5)*0.003, (Math.random()-0.5)*0.005));
                            if (Math.abs(posAttr.array[i*3+0]) > 7) ff.velocity.x *= -0.9;
                            if (posAttr.array[i*3+1] < 0.5 || posAttr.array[i*3+1] > 7) ff.velocity.y *= -0.9;
                            if (Math.abs(posAttr.array[i*3+2]) > 7) ff.velocity.z *= -0.9;
                            const blink = Math.sin(time * (1.5 + audioLevel*2.0) + ff.blinkOffset) + Math.sin(time*0.6 + ff.blinkOffset*0.7);
                            if (blink > 0.9) collectiveOpacity += ((blink - 0.9)/1.1) * (0.6 + audioLevel*0.4);
                        }
                        material.opacity = Math.min(1.0, collectiveOpacity / (particleCount * 0.15) + 0.05 );
                        posAttr.needsUpdate = true;
                    }
                };
            }

            const beginARExperience = () => {
                if (startExperienceUI) startExperienceUI.style.display = 'none';
                if (loadingMessage) {
                    loadingMessage.innerHTML = "Loading AR assets...";
                    loadingMessage.style.display = 'block';
                }
                if (controlsDiv) controlsDiv.style.display = 'block';

                loadAllAssets(() => {
                    if (typeof THREE === 'undefined' || typeof MindARThree === 'undefined') {
                        if(loadingMessage) loadingMessage.innerHTML = "Error: Critical libraries (THREE or MindAR) not loaded. Check importmap and module imports.";
                        console.error("THREE or MindARThree (module) not loaded.");
                        return;
                    }
                    initMindAR().catch(err => {
                         if(loadingMessage) loadingMessage.innerHTML = "Failed to initialize AR. Check console, permissions, and .mind file path.<br><small>" + err.message + "</small>";
                         console.error("Failed to initialize AR:", err);
                    });
                });
            };

            if (startArButton) {
                startArButton.addEventListener('click', beginARExperience);
            } else {
                console.error("Start AR Button not found. AR experience cannot be initiated by user.");
                if(loadingMessage) {
                    loadingMessage.innerHTML = "Error: Start button missing. Cannot initialize.";
                    loadingMessage.style.display = 'block';
                }
            }
        });
    </script>
</body>
</html>
